#!/usr/bin/env python
# TODO we assume that the python executable running this script will actually work inside a
# rez-env'd environment, what if this is not the case? The solution then becomes much
# trickier.
import os


def _add_common_args(subp):
    pass


if __name__ == '__main__':
    # Test if this script is being run from an env correctly configured for Rez. Often this
    # is not the case, because a rez-env'd environment is configured for the requested pkgs,
    # not for Rez itself.
    # TODO may not need this now, monkey-patch in install instead...
    """
    do_configure = False
    install_base = os.getenv("REZ_INSTALL_BASE")
    if install_base:
        try:
            import rez
            assert(rez.__path__.startswith(install_base))
        except:
            do_configure = True

    # rejig the env so rez can operate correctly
    if do_configure:
        import sys
        import site
        site.addsitedir(install_base)
        sys.path.insert(0, install_base)
    """

    # cli
    import argparse
    p = argparse.ArgumentParser(
        description='Rez command-line tool',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    subps = p.add_subparsers(dest="cmd")
    cmds = {}

    def _add_subcommand(cmd, help):
        subp = subps.add_parser(cmd, help=help)
        _add_common_args(subp)
        exec("from rez.cli.%s import setup_parser" % cmd)
        setup_parser(subp)
        cmds[cmd] = subp

    _add_subcommand("settings",     "Print current rez settings.")
    _add_subcommand("env",          "Open a resolved interactive shell.")

    opts = p.parse_args()
    cmd = opts.cmd
    exec("from rez.cli.%s import command" % cmd)
    command(opts, cmds[cmd])

    from rez.util import clean_tmpdir
    #clean_tmpdir()
